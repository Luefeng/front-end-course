今天面试回来，像往常一样打开手机，看到QQ群上有个加群申请，进群得回答问题：`true == '0'`,看到有个申请的答案为false,然后我就自信的点了**拒绝**:smile:。闲着无聊，打开电脑在控制台上输入题目，结果为false,我就很好奇为什么是这样呢？明明两边的值都会为true啊，为什么会错呢（被拒绝的童鞋不要怪我）。带这个这个疑问我翻了下*你不知道的javascript*

javascript中的值分为两类：
1. 可以被强制转化为false的值
2. 其他（可以被强制转化为true的值）

我们知道能转换为false的基本类型有,我们称其为假值：
- undefined
- null
- ""
- 0和NaN
- false

那么，上面的值既然可以转化为false，我们的`true == '0'`两边都可以转化为true，那么为什么不相等呢？

我们先来说下宽松相等“==”和“===”。在以往的理解中，我的理解一直是：“==”表示两个值相等，“===”表死两个值和类型相等。但是书中说，它们的理解应该说是这样：“==允许在相等比较中进行强制类型转化，===不允许”，还是不太理解，两种理解有什么区别吗？暂时放一放，我们往后看。。。

下面摘抄一段树上写的区别：
> 根绝第一种解释，===似乎比==做的事情更多，因为它还要检查值的类型，第二种解释中==的工作量更大一些，因为如果值的类型相同海需要进行强制类型转化。

> 如果两个值的类型不同，我们就需要考虑有没有强制类型转化的必要，有就用==，否则用===

接下来我们来看几种比较来加深理解

1. 字符串和数字的比较

```javascript
var a = 4;
var b = "4";
a == b //true
a === b //false
```
这个结果大家应该都知道，但是 == 比较时，是将两边的值全部转化为数字呢还是转化为字符串比较呢？未完待续。。。（皮一下:smile:）


哈哈，开个玩笑，公布答案：转化为数字。依据就是：
> ES5规范11.9.3.4-5这样定义(ToNumber强制转化为数字)  
（1）如果Type(x)是数字，Type(y)是字符串，则返回x == ToNumber(y)的结果  
（2）如果Type(x)是字符串，Type(y)是数字，则返回ToNumber == y的结果 


2. 其他类型与布尔值比较  

我觉得这一块我们理解的误区比较多，也是出错最多的一块。

例如：
```javascript
var a = true;
var b = 4;
a == b //false
```
以往我们的理解是：数字4是一个真值（与假值对应），会转化为true，从而两边相等。哪里错了呢？我们直接来看ES标准

> ES5规范11.9.3.6-7这样定义(ToNumber强制转化为数字)  
（1）如果Type(x)是布尔值，则返回ToNumber(x) == y的结果  
（2）如果Type(y)是布尔值，则返回x == ToNumber(y)的结果 

原来比较的时候是将布尔值转化为数字，即：
```javascript
var a = true;
var b = 4;
var c = true;
var d = "12";
a == b ===>  1 == 4  //false
c == d ===> 1 == "12" ===> 1 == 12  //false
```
这样是不是清楚多了，所以我们判断的时候别用( a == true)这种判断。注意：如果x,y中存在 null或undefiend，则参考第三点

3. null和undefined之间的比较
> ES5规范11.9.3.2-3这样定义  
（1）如果x为null，y为undefined，则返回true  
（2）如果x为undefined，y为null,则返回true

在 == 中，null和undefined相等，除此之外不存在这种情况 
```javascript
var a = null;
var b;
a == b  //true
a == false //false
b == false //false
a == 0  //false
b == 0 //false
a == ""  //false
b == ""  //false
```

今天就写到这里，第一次写文章，如有什么不对的地方，还望大家指正